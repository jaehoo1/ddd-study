# DDD(Domain Driven Design) 개념 이해하기
DDD라는 개념이 조금 낮설어 개념 이해를 위한 self 스터디

## Domain
- 사전적 의미는 '영역', '집합'
- DDD에서의 Domain : **비즈니스 Domain**
- 비즈니스 Domain : **유사한 업무의 집합** (상품, 주문, 정산, 대금, 물류, ...)
- 어플리케이션은 비즈니스 Domain별로 나누어 설계 및 개발 될 수 있다.

## DDD - Domain Driven Design
비즈니스 Domain별로 나누어 설계하는 방식이다.  
DDD는 [Strategic Design](#strategic-design)과 Tactical Design으로 나눌 수 있다. Strategic Design은 개념 설계이고 Tactical Design은 프로그래밍하기 위한 구체적 설계라고 할 수 있다.

### DDD의 핵심 목표
DDD의 핵심 목표는 "Loosly coupling", "High cohesion"이다.  
(어플리케이션 또는 그 안의 모듈간의 의존성은 최소화하고, 응집성은 최대화)

### Strategic Design
Business Domain의 상황(Context: 대상사용자, 상황)에 맞게 설계하자는 컨셉
- 전략적 설계를 위해 Business Domain의 상황(Context)을 Event Storming으로 공유하고, 비즈니스 목적별로 서비스들을 그룹핑한다.
- Bounded Context & Domain Model
- Bounded Context & Micro Service : 1개의 Bounded Context는 최소한 1개 이상의 Micro Service로 구성된다.
- Context Map : Bounded Context간의 관계를 나타낸 도식화한 Diagram이다.
- [Ubiquitous Language](#ubiquitous-language유비쿼터스-언어)

<br/>

## 왜 DDD가 필요한가? (DDD의 핵심 목적)
1. **복잡한 비즈니스 로직을 잘 설계하고 유지보수하기 위해**
- 실무에서는 UI보다는 **비즈니스 규칙(도메인 로직)** 이 더 복잡한 경우가 많음
- 기존의 기술 중심 설계는 이러한 복잡한 도메인을 잘 표현하지 못하고, 점점 더 스파게티 코드가 됨
- DDD는 도메인을 정확하고 명확하게 모델링하여 로직을 잘 담을 수 있게 해줌

<br/>

2. **개발자와 비즈니스 담당자가 같은 언어를 사용하게 하기 위해 ([Ubiquitous Language](#ubiquitous-language유비쿼터스-언어))**
- 고객이나 기획자가 말하는 것과 개발자가 구현하는 것 사이에 의미의 불일치가 자주 발생함
- DDD는 "[유비쿼터스 언어](#ubiquitous-language유비쿼터스-언어)"라는 개념을 통해, 모두가 같은 단어로 이야기하고 이해하도록 유도함
- 이는 오해를 줄이고 요구사항을 정확히 반영할 수 있게 함

<br/>

3. **기능이 늘어나도 구조가 망가지지 않게 하기 위해**
- 일반적인 구조는 기능이 많아질수록 Service에 모든 로직이 몰리는 현상이 나타남
- DDD는 도메인을 중심으로 객체 간 역할과 책임을 명확히 분리하여, 시스템이 커져도 견고하게 유지할 수 있게 함

<br/>

4. **효율적인 협업과 테스트를 위해**
- 도메인 모델을 중심으로 코드를 구성하면, 각 팀(프론트, 백엔드, QA 등)이 명확한 계약과 역할 아래 협업할 수 있음
- 또한, 도메인 로직이 객체 안에 잘 분리되어 있으면, 단위 테스트도 쉽고 정확하게 가능함

<br/>

5. **비즈니스 변화에 유연하게 대응하기 위해**
- 비즈니스 요구사항은 자주 바뀜
- 도메인에 집중하여 모델을 설계하면, 변경이 있어도 영향을 최소화하면서 유연하게 대응할 수 있음

<br/>

### Ubiquitous Language(유비쿼터스 언어)
**모두가 사용하는 공통의 언어**로, 비즈니스 전문가와 개발자 간의 소통, 코드, 문서, 테스트 이름까지 모두 일치시켜 도메인 지식을 정확하게 반영하는 언어 체계  
기획자도 이해할 수 있고, 개발자도 코드에 그대로 쓸 수 있는 언어를 만들고, 모든 대화, 문서, 설계, 코드에서 그 용어만 사용하자는 개념

|구분|설명|
|---|---|
|정의|개발자와 비즈니스 전문가가 공통으로 사용하는 언어|
|목적|요구사항 이해, 설계, 구현 사이의 의미 불일치 제거|
|적용|회의, 문서, 코드(`Class`, `Method`, `Enum`, 테스트명 등)에 동일하게 사용|
|효과|소통 개선, 오류 감소, 도메인 지식이 코드에 녹아듦|

<br/>

#### 유비쿼터스 언어가 왜 중요한지
##### 일반적인 상황
- 기획자 : "이거 정산은 자동으로 되죠?"
- 개발자 : "자동 정산 로직에서 InvoiceService가 TaxEntity에 Access해서 처리합니다."

서로 이해가 안 되는 말 : 기획자는 시스템 내부 구조를 모르고, 개발자는 비즈니스 개념을 코드 용어로만 설명함

##### 유비쿼터스 언어를 사용하는 경우
- 기획자 : "이번 주문(Order)이 취소되면, 정산 상태를 보류(Pending)로 바꿔주세요."
- 개발자 : "알겠습니다. 정산 상태(PaymentStatus)를 보류로 설정하겠습니다."

둘 다 동일한 개념(정산, 보류, 주문)을 같은 단어로 이해하고, 개발자는 이걸 `PaymentStatus` `enum`으로 코드에 반영함.

❌ 이해 안 되는 코드 → ✅ 비즈니스가 보이는 코드  
❌ 요구사항 전달 오류 → ✅ 요구와 코드가 일치  
❌ 기획자 vs 개발자 대립 → ✅ 같은 팀, 같은 언어

<br/>

#### 유비쿼터스 언어는 단순한 용어 정의가 아님
"언제나(ubiquitous)" 사용해야 의미 있음  
코드, 회의, 문서, 테스트 전반에 걸쳐 일관되게 사용해야 함  
만약 개발자가 자기만의 이름을 쓰기 시작하면 DDD는 실패함

<br/>

#### 어떻게 만드나?
- 기획자/현업과 대화하면서 개념 정리
  - 주문, 정산, 결제, 보류, 승인, 취소 등 실제 업무에서 쓰이는 단어를 정확히 정의
- 그 단어들을 모델과 코드에 그대로 반영
  - 예: `Order`, `PaymentStatus`, `CancelPolicy` 같은 클래스/필드명
- 혼동되는 용어는 제거하고 하나로 통일
  - '취소', '삭제', '무효'가 같은 의미라면, 하나로 통일 (예: '취소')

## References
- https://happycloud-lee.tistory.com/94