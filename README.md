# DDD(Domain Driven Design) 개념 이해하기
DDD라는 개념이 조금 낮설어 개념 이해를 위한 self 스터디

## Domain
- 사전적 의미는 '영역', '집합'
- DDD에서의 Domain : **비즈니스 Domain**
- 비즈니스 Domain : **유사한 업무의 집합** (상품, 주문, 정산, 대금, 물류, ...)
- 어플리케이션은 비즈니스 Domain별로 나누어 설계 및 개발 될 수 있다.

## DDD - Domain Driven Design
비즈니스 Domain별로 나누어 설계하는 방식이다.  
DDD는 [Strategic Design](#strategic-design)과 Tactical Design으로 나눌 수 있다. Strategic Design은 개념 설계이고 Tactical Design은 프로그래밍하기 위한 구체적 설계라고 할 수 있다.

### DDD의 핵심 목표
DDD의 핵심 목표는 "Loosly coupling", "High cohesion"이다.  
(어플리케이션 또는 그 안의 모듈간의 의존성은 최소화하고, 응집성은 최대화)

### Strategic Design
Business Domain의 상황(Context: 대상사용자, 상황)에 맞게 설계하자는 컨셉
- 전략적 설계를 위해 Business Domain의 상황(Context)을 Event Storming으로 공유하고, 비즈니스 목적별로 서비스들을 그룹핑한다.
- [Bounded Context](#bounded-context) & Domain Model
- Bounded Context & Micro Service : 1개의 Bounded Context는 최소한 1개 이상의 Micro Service로 구성된다.
- Context Map : Bounded Context간의 관계를 나타낸 도식화한 Diagram이다.
- [Ubiquitous Language](#ubiquitous-language유비쿼터스-언어)

#### Bounded Context
Biz Domain의 사용자, 프로세스, 정책/규정 등을 고유한 비즈니스 목적별로 그룹핑 한 것  
- 사용자, 프로세스, 정책/규정들을 그 Biz Domain의 Context라고 말할 수 있으므로 Bounded Context는 Domain안의 서비스를 경계 지은 Context의 집합이라고 할 수 있다.
- 도메인을 기능이나 목적에 따라 명확하게 구분하여 책임과 의미가 충돌하지 않도록 하는 개념
- 하나의 시스템에서도 여러 개의 Bounded Context가 존재할 수 있으며, 각 Context는 자체적인 모델, 용어, 규칙을 가진다.

ex) E-Commerce Bounded Context
1. 주문(Order) Context  
주문 생성, 장바구니, 결제(Payment) 처리 등 주문 관련 도메인을 담당하는 Bounded Context
2. 상품(Product) Context  
상품 정보 관리, 재고, 카테고리, 리뷰 등 담당하는 Bounded Context
3. 물류(Logistics) / 배송(Shipping) Context  
출고, 송장, 택배사 연동, 재고, ... 담당하는 Bounded Context
4. ...

주문 Context는 상품 Context나 물류 Context와는 **별도로 관리**된다.  
예를 들어 주문 Context에서는 "상품의 이름과 가격"만 필요하지만, 상품 Context에서는 카테고리, 상품 리뷰 등도 관리한다. 두 Context 간의 통신은 도메인 이벤트나 API 호출 등을 통해 이루어질 수 있다.
> "상품의 이름과 가격"을 상품 RDBMS의 PK라고 표현하지 않은 이유는, DDD는 비즈니스 관점에서 도메인을 모델링 하는 것이지, 개발자들만이 모델링 하는게 아니다.

> 주문 Context에 포함된 결제(Payment) 같은 경우는 주문 Context에 포함될 수도, 완전히 독립된 Bounded Context로 분리될 수도 있다. → 정답이 있는 게 아니라 "설계의 선택"이다.  
> 1. 결제가 주문 Context 안에 포함된 경우
> - 결제가 단순할 때 (ex. 한 가지 PG사, 결제 방식도 간단)
> - 결제 상태 변화가 주문의 부가적인 상태 정도로만 필요할 때 : `Order` 엔터티 안에 `paymentStatus`, `paymentMethod`, `paidAt` 같은 속성 포함. `OrderService.payOrder()`
> - 조직상 주문/결제를 동일한 팀이 관리할 때
> - 장점 : 설계가 단순함, 의존성 없이 빠르게 구현 가능
> - 단점 : 추후 PG 연동, 다양한 결제 수단 추가 시 복잡해짐, 재사용성 떨어짐 (ex : 구독 결제 시스템 등 다른 영역에서 활용 어려움)
> 2. 결제를 별도 Bounded Context로 분리한 경우
> - 결제가 복잡할 때 (PG 연동, 환불/승인 취소, 무통장 입금 등)
> - 결제를 다른 도메인에서도 활용할 때 (예: 정기 결제, 멤버십 결제)
> - 결제 도메인 전담팀이 있을 때 (조직 경계와도 일치)
> - Order는 "결제 요청 이벤트"를 발행 → 결제 Context는 이를 받아 실제 결제 처리, 결제 결과 이벤트를 다시 발행 → Order는 해당 이벤트를 구독해서 상태를 업데이트
> - 장점 : 복잡한 결제 로직을 독립적으로 관리 가능, Order 외의 도메인에서도 재사용 가능, 마이크로서비스화 용이
> - 단점 : 컨텍스트 간 통신(이벤트, API 등) 필요, 구현 복잡도 증가
>
> 초기에는 결제를 주문 Context 안에 포함시켰다가, 시스템이 커지거나 결제가 복잡해지면 분리하는 방식도 괜찮다.  
> 이 때 중요한 건, 명확한 경계를 인식하고 분리 가능한 구조로 만들어 두는 것이다(확장 가능성).

이렇게 Context들을 역할과 책임에 따라 경계(Bounded) 지어 독립적으로 설계하는 것이 DDD에서 핵심이다.

<br/>

## 왜 DDD가 필요한가? (DDD의 핵심 목적)
1. **복잡한 비즈니스 로직을 잘 설계하고 유지보수하기 위해**
- 실무에서는 UI보다는 **비즈니스 규칙(도메인 로직)** 이 더 복잡한 경우가 많음
- 기존의 기술 중심 설계는 이러한 복잡한 도메인을 잘 표현하지 못하고, 점점 더 스파게티 코드가 됨
- DDD는 도메인을 정확하고 명확하게 모델링하여 로직을 잘 담을 수 있게 해줌

<br/>

2. **개발자와 비즈니스 담당자가 같은 언어를 사용하게 하기 위해 ([Ubiquitous Language](#ubiquitous-language유비쿼터스-언어))**
- 고객이나 기획자가 말하는 것과 개발자가 구현하는 것 사이에 의미의 불일치가 자주 발생함
- DDD는 "[유비쿼터스 언어](#ubiquitous-language유비쿼터스-언어)"라는 개념을 통해, 모두가 같은 단어로 이야기하고 이해하도록 유도함
- 이는 오해를 줄이고 요구사항을 정확히 반영할 수 있게 함

<br/>

3. **기능이 늘어나도 구조가 망가지지 않게 하기 위해**
- 일반적인 구조는 기능이 많아질수록 Service에 모든 로직이 몰리는 현상이 나타남
- DDD는 도메인을 중심으로 객체 간 역할과 책임을 명확히 분리하여, 시스템이 커져도 견고하게 유지할 수 있게 함

<br/>

4. **효율적인 협업과 테스트를 위해**
- 도메인 모델을 중심으로 코드를 구성하면, 각 팀(프론트, 백엔드, QA 등)이 명확한 계약과 역할 아래 협업할 수 있음
- 또한, 도메인 로직이 객체 안에 잘 분리되어 있으면, 단위 테스트도 쉽고 정확하게 가능함

<br/>

5. **비즈니스 변화에 유연하게 대응하기 위해**
- 비즈니스 요구사항은 자주 바뀜
- 도메인에 집중하여 모델을 설계하면, 변경이 있어도 영향을 최소화하면서 유연하게 대응할 수 있음

<br/>

### Ubiquitous Language(유비쿼터스 언어)
**모두가 사용하는 공통의 언어**로, 비즈니스 전문가와 개발자 간의 소통, 코드, 문서, 테스트 이름까지 모두 일치시켜 도메인 지식을 정확하게 반영하는 언어 체계  
기획자도 이해할 수 있고, 개발자도 코드에 그대로 쓸 수 있는 언어를 만들고, 모든 대화, 문서, 설계, 코드에서 그 용어만 사용하자는 개념

|구분|설명|
|---|---|
|정의|개발자와 비즈니스 전문가가 공통으로 사용하는 언어|
|목적|요구사항 이해, 설계, 구현 사이의 의미 불일치 제거|
|적용|회의, 문서, 코드(`Class`, `Method`, `Enum`, 테스트명 등)에 동일하게 사용|
|효과|소통 개선, 오류 감소, 도메인 지식이 코드에 녹아듦|

<br/>

#### 유비쿼터스 언어가 왜 중요한지
##### 일반적인 상황
- 기획자 : "이거 정산은 자동으로 되죠?"
- 개발자 : "자동 정산 로직에서 InvoiceService가 TaxEntity에 Access해서 처리합니다."

서로 이해가 안 되는 말 : 기획자는 시스템 내부 구조를 모르고, 개발자는 비즈니스 개념을 코드 용어로만 설명함

##### 유비쿼터스 언어를 사용하는 경우
- 기획자 : "이번 주문(Order)이 취소되면, 정산 상태를 보류(Pending)로 바꿔주세요."
- 개발자 : "알겠습니다. 정산 상태(PaymentStatus)를 보류로 설정하겠습니다."

둘 다 동일한 개념(정산, 보류, 주문)을 같은 단어로 이해하고, 개발자는 이걸 `PaymentStatus` `enum`으로 코드에 반영함.

❌ 이해 안 되는 코드 → ✅ 비즈니스가 보이는 코드  
❌ 요구사항 전달 오류 → ✅ 요구와 코드가 일치  
❌ 기획자 vs 개발자 대립 → ✅ 같은 팀, 같은 언어

<br/>

#### 유비쿼터스 언어는 단순한 용어 정의가 아님
"언제나(ubiquitous)" 사용해야 의미 있음  
코드, 회의, 문서, 테스트 전반에 걸쳐 일관되게 사용해야 함  
만약 개발자가 자기만의 이름을 쓰기 시작하면 DDD는 실패함

<br/>

#### 어떻게 만드나?
- 기획자/현업과 대화하면서 개념 정리
  - 주문, 정산, 결제, 보류, 승인, 취소 등 실제 업무에서 쓰이는 단어를 정확히 정의
- 그 단어들을 모델과 코드에 그대로 반영
  - 예: `Order`, `PaymentStatus`, `CancelPolicy` 같은 클래스/필드명
- 혼동되는 용어는 제거하고 하나로 통일
  - '취소', '삭제', '무효'가 같은 의미라면, 하나로 통일 (예: '취소')

## References
- https://happycloud-lee.tistory.com/94